---
title: "Flytrap Example: Qubit and Gates"
description: |
  This is an example to apply for an internship at Quantum Flytrap
author:
  - name: Claudia Zendejas-Morales
    url: http://claudiazm.xyz
date: "`r Sys.Date()`"
output: distill::distill_article
bibliography: refs.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r echo=FALSE, message=FALSE, results='asis'}
cat(
  "<link rel='stylesheet' href='https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css'>",
  "<script src='https://cdn.jsdelivr.net/npm/vue@2.6.12'></script>",
  "<script src='https://unpkg.com/quantum-tensors@0.4.14/dist/quantum-tensors.min.js'></script>",
  "<script src='https://unpkg.com/bra-ket-vue@0.3.1/dist/bra-ket-vue.min.js'></script>",
  "<script src='https://cdn.jsdelivr.net/npm/sortablejs@1.8.4/Sortable.min.js'></script>",
  "<script src='https://cdnjs.cloudflare.com/ajax/libs/Vue.Draggable/2.20.0/vuedraggable.umd.min.js'></script>",
  "<script src='https://cdn.jsdelivr.net/npm/vue-round-slider@1.0.1/dist/vue-roundslider.min.js'></script>"
)
```


Quantum computing is the use of quantum phenomena such as superposition and entanglement to perform computation.  There are several models of quantum computers, including the quantum circuit model, adiabatic quantum, amog others. Quantum circuits are based on the **qubit**. 

A **qubit** is the equivalent to a *bit* in classical computation. A qubit is a two-state (or two-level) quantum-mechanical system, we write qubits with Dirac notation.

The general quantum state of a qubit can be represented by a linear superposition of its two orthonormal basis states (or basis vectors). These vectors are usually denoted as $|0\rangle$ and $|1\rangle$:

$$|0\rangle = \begin{bmatrix}
1\\
0
\end{bmatrix}
\; \; \; , \; \; \;
|1\rangle = \begin{bmatrix}
0\\
1
\end{bmatrix}$$

Therefore, the quantum state of a qubit $|\psi\rangle$ can be $|\psi\rangle=|0\rangle$ or $|\psi\rangle=|1\rangle$ or $|\psi\rangle=\alpha|0\rangle +\beta|1\rangle$ (a superposition), where $\alpha$ and $\beta$ are complex numbers [@Mermin07].

The **Bloch sphere** is a geometrical representation of the pure state space of a two-level quantum mechanical system (qubit). The north and south poles of the Bloch sphere are typically chosen to correspond to the standard basis vectors $|0\rangle$  and $|1\rangle$, respectively, which in turn might correspond e.g. to the spin-up and spin-down states of an electron.

Therefore, it is possible to define a state using $\theta$ and $\phi$ which correspond to the definition of the Bloch sphere as follows [@Nielsen16]:

$$|\psi\rangle = \cos\left(\tfrac{\theta}{2}\right) \; |0\rangle + e^{i\phi} \; \sin\left(\tfrac{\theta}{2}\right) \; |1\rangle$$

thus,

$$\alpha=\cos\left(\tfrac{\theta}{2}\right) \; \; \; \; \; , \; \; \; \; \; \beta=\left(\cos\phi+i\sin\phi\right)\sin\left(\tfrac{\theta}{2}\right)$$
where,

$$0\leq \theta \leq \pi \; \; \text{and} \; \;  0\leq \phi <2\pi$$

<br>
<br>

To this qubits we can apply **quantum gates**, so we can modify its state. This quantum gates have different effects, let's see some of them when starting with state $|0\rangle$:

<br>

(Click on the quantum gate you want to apply to the qubit $|0\rangle$)


```{r}
HTML("
<div id='gates1'>
  <label>
    <input type='radio' name='gate_applied' v-on:click='show = 1' value='x' checked> 
    X Gate
  </label>
  <label>
    <input type='radio' name='gate_applied' v-on:click='show = 2' value='y'> 
    Y Gate
  </label>
  <label>
    <input type='radio' name='gate_applied' v-on:click='show = 3' value='z'>
    Z Gate
  </label>
  <label>
    <input type='radio' name='gate_applied' v-on:click='show = 4' value='h'>
    H Gate
  </label>
  
  <br><br>

  <div class='gate_title' v-show='show == 1'>
    Apply X Gate:
    <div id='ketlist1'></div>
  </div>
  
  <div class='gate_title' v-show='show == 2'>
    Apply Y Gate:
    <div id='ketlist2'></div>
  </div>
  
  <div class='gate_title' v-show='show == 3'>
    Apply Z Gate:
    <div id='ketlist3'></div>
  </div>
  
  <div class='gate_title' v-show='show == 4'>
    Apply H Gate:
    <div id='ketlist4'></div>
  </div>

</div> <!-- end id='gates1' -->

")
```

<br>
<br>

But we can also start with state $|1\rangle$, to see this, now we use a matrix representation of the quantum gates.

Each gate is a matrix that you multiply by the left of the qubit (remember, a qubit is a vector).

In this representation we can see which is the output (the state after applying a gate) for each possible input ($|0\rangle$ or $|1\rangle$).

<br>

(Place your pointer on the input you want to review and the corresponding output will be the one with a colored circle)

<br>

```{r}
HTML("
  <table align='center' class='matrices'>
    <tr>
      <td align='center'>
        X Gate (Pauli X)
        <div id='gate-x'></div>
      </td>
      <td align='center'>
        Y Gate (Pauli Y)
        <div id='gate-y'></div>
      </td>
    </tr>
    <tr>
      <td align='center'>
        Z Gate (Pauli Z)
        <div id='gate-z'></div>
      </td>
      <td align='center'>
        H Gate (Hadamard)
        <div id='gate-h'></div>
      </td>
    </tr>
  </table>
")
```

<br>
<br>

Of course, you can also apply gates in sequence to modify the state of the qubit as needed depending on your algorithm.

The following example applies the gates $Z$, $H$, $X$ (in that order).

This in Dirac notation looks like:

$$ X \;H \; Z \; |0\rangle $$

Note that the order of application is first the gate closest to state $|0\rangle$ and then the one that follows from right to left.

<div id='ketlist5'></div>

<br>
<br>
<br>


You can test for yourself the effect of the different gates, simply drag the gate you want to apply to the *selected gates* area, to delete a gate from that area, you must drag it to the trash area that appears below when you select a gate.

Observe how the state changes according to the applied gates.

To change the *initial state* use the sliders until you find the desired value for each angle (given in fractions of $\pi$) or you can capture it directly by clicking on the central part of each slider.

<div id='state'>

  <table align="center" style="border:none;">
    <tr>
      <td>
        <!-- Vue Round Slider -->
        <round-slider
          class="theta"
          v-model="thetaVal"
          start-angle="0"
          end-angle="180"
          line-cap="round"
          radius="80"
          width="10"
          animation="false"
          handle-size="22"
          handle-shape="round"
          min="0"
          max="1"
          step="0.01"
          range-color="#ff0055"
          circle-shape="full"
          v-bind:tooltip-format="formatTheta"
          v-bind:value-change="changeAngles">
        </round-slider>
        <!-- === -->
      </td>
      <td>
        <round-slider
          class="phi"
          v-model="phiVal"
          start-angle="0"
          end-angle="360"
          line-cap="round"
          radius="80"
          width="10"
          animation="false"
          handle-size="22"
          handle-shape="round"
          min="0"
          max="2"
          step="0.01"
          range-color="#5c00d3"
          circle-shape="full"
          v-bind:tooltip-format="formatPhi"
          v-bind:value-change="changeAngles">
        </round-slider>
      </td>
    </tr>
  </table>

<p align='center'>
<span style='font-family: Asana Math; font-size:20px;'>
  |&#x03C8;&rangle; = {{state_a}} |0&#x27E9;<!-- ⟩ --> + ( {{state_b}} ) |1&#x27E9;<!-- ⟩ -->
</span>
</p>

</div>
<div id='dnd'></div>
<div id='ketlist6'></div>



```{js, results='asis', echo=FALSE, message=FALSE}

const { Circuit, Gates, Vector, Cx, Dimension } = QuantumTensors;
const { KetListViewer, MatrixViewer } = BraKetVue;


const circuitHistory = [];
Circuit.qubits(1)
  .saveTo(circuitHistory)
  .X(0)
  .saveTo(circuitHistory)

Circuit.qubits(1)
  .Y(0)
  .saveTo(circuitHistory)

Circuit.qubits(1)
  .Z(0)
  .saveTo(circuitHistory)

Circuit.qubits(1)
  .H(0)
  .saveTo(circuitHistory)

const circuitHistoryBig = [];
Circuit.qubits(1)
  .saveTo(circuitHistoryBig)
  .Z(0)
  .saveTo(circuitHistoryBig)
  .H(0)
  .saveTo(circuitHistoryBig)
  .X(0)
  .saveTo(circuitHistoryBig);


function addKetList(name, gate, cirq) {

  new Vue({
    el: '#'+name+cirq,
    template: "<ket-list-viewer :steps='stepsQuantumComputing' :dark-mode='false'/>",
    components: {
      KetListViewer,
    },
    data() {
  	  return {
        stepsQuantumComputing: [
          { value: 'Initial state', vector: circuitHistory[0].vector },
          { value: 'After apply '+gate+' gate', vector: circuitHistory[cirq].vector },
        ],
  	  }
    }
  })
}

function addGate(name, operator) {

  new Vue({
    el: '#'+name,
    template: "<matrix-viewer :operator-raw='operator' :dark-mode='false'/>",
    components: {
      MatrixViewer,
    },
    data() {
  	  return { operator }
    }
  })
}


new Vue({
  el: '#gates1',
  data: {
          show: 1
  }
});


addKetList('ketlist','X',1);
addKetList('ketlist','Y',2);
addKetList('ketlist','Z',3);
addKetList('ketlist','H',4);


addGate('gate-x', Gates.X());
addGate('gate-y', Gates.Y());
addGate('gate-z', Gates.Z());
addGate('gate-h', Gates.H());


new Vue({
  el: '#ketlist5',
  template: "<ket-list-viewer :steps='stepsQuantumComputing' :dark-mode='false'/>",
  components: {
    KetListViewer,
  },
  data() {
	  return {
      stepsQuantumComputing: [
        { value: 'Initial state', vector: circuitHistoryBig[0].vector },
        { value: 'Apply Z gate', vector: circuitHistoryBig[1].vector },
        { value: 'Apply H gate', vector: circuitHistoryBig[2].vector },
        { value: 'Apply X gate', vector: circuitHistoryBig[3].vector },
      ],
	  }
  }
});

updateGates = function() {}

var dnd = new Vue({
  el: '#dnd',
  template: `
  <div>
  
    <div>
      <fieldset class="box-available">
        <legend class="legend-text">Available gates</legend>
        <draggable
          class="row"
          :list="availableGates"
          :group="{ name: '1qGates', pull: 'clone', put: false }"
          :sort="false"
          chosen-class="chosen"
        >
          <div
            class="col-auto list-group-item"
            v-for="gate in availableGates"
            v-bind:class="gate.class"
            :key="gate.name"
          >
            {{ gate.name }}
          </div>
        </draggable>
      </fieldset>
    </div>
    
    <br><br>
    
    <table class=table-circuit>
      <tr>
        <td>
          <div>
            <fieldset class="box-selected">
              <legend class="legend-text">Selected gates</legend>
              <draggable
                class="row dragArea"
                :list="selectedGates"
                group="1qGates"
                @change="setGates"
                chosen-class="chosen"
                @choose="showTrashArea"
                @end="hideTrash"
                @update="hideTrash"
              >
                <div
                  class="col-auto list-group-item"
                  v-for="(gate,index) in selectedGates"
                  v-bind:class="gate.class"
                  :key="gate.name"
                  @click="deleteItem(index)"
                >
                  {{ gate.name }}
                </div>
              </draggable>
            </fieldset>
          </div>
        </td>
        <td>
          <span style="font-family: MathJax_Main; font-size:30px;">|&#x03C8;&rangle;</span>
        </td>
      </tr>
      <tr>
        <td>
          <div v-show='showTrash'>
            <fieldset class="box-selected">
              <legend class="legend-text">Trash &#x1F5D1;</legend>
              <draggable
                class="row dragArea"
                :list="deletedGates"
                group="1qGates"
                chosen-class="chosen"
                @add="hideTrash"
              >
              </draggable>
            </fieldset>
          </div>
        </td>
        <td>
        </td>
      </tr>
    </table>
    
  </div>
  `,
  data() {
    return {
      availableGates: [
        { name: "X" , class: "x-class selected" },
        { name: "Y" , class: "y-class selected" },
        { name: "Z" , class: "z-class selected" },
        { name: "H" , class: "h-class selected" },
        { name: "I" , class: "i-class selected" },
        { name: "S" , class: "s-class selected" },
        { name: "T" , class: "t-class selected" }
      ],
      selectedGates: [
        { name: "X" , class: "x-class selected" },
        { name: "H" , class: "h-class selected"}
      ],
      deletedGates: [],
      showTrash: 0,
    };
  },
  methods: {
    deleteItem(index) {
      //this.selectedGates.splice(index, 1);
      //this.setGates();
      this.hideTrash();
    },
    setGates() {
      this.hideTrash();
      updateGates();
    }, 
    showTrashArea() {
      this.showTrash = true;
    },
    hideTrash() {
      this.showTrash = false;
    }
  }
});

var stateSlider = new Vue({
  el: "#state",
  data: {
    thetaVal: 0.5,
    phiVal: 1.0,
    alpha: 0.707,
    beta_r: -0.707,
    beta_i: 0,
  },
  methods: {
    formatTheta() {
      return "<span class='round-slider-font'>&theta; = " + this.thetaVal + " &pi;</span>";
    },
    formatPhi() {
      return "<span class='round-slider-font'>&phi; = " + this.phiVal + " &pi;</span>";
    },
    changeAngles() {
      let cos_theta_2 = Math.cos(this.thetaVal*Math.PI / 2);
      let sin_theta_2 = Math.sin(this.thetaVal*Math.PI / 2);
      let cos_phi = Math.cos(this.phiVal*Math.PI);
      let sin_phi = Math.sin(this.phiVal*Math.PI);
      let b_r = cos_phi * sin_theta_2;
      let b_i = sin_phi * sin_theta_2;
      
      this.alpha = cos_theta_2;
      this.beta_r = b_r ;
      this.beta_i = b_i;
      
      updateGates();
      
    },
  },
  computed: {
  	state_a() {
      let a = Math.round(this.alpha * 1000) / 1000;
    	return a !== 0 ? a : '0';
    },
    state_b() {
      let b_r = Math.round(this.beta_r * 1000) / 1000;
      let b_i = Math.round(this.beta_i * 1000) / 1000;
      if (b_r === 0 && b_i === 0) return '0';
      let sgn = ' + '; 
      if (b_i < 0) { 
        sgn = ' - '; 
        b_i = -b_i;
      }
    	return (b_r !== 0 ? b_r : '') + (b_i !== 0 ? sgn + b_i + ' i' : '');
    },
  },
});


circ = new Circuit(
  Vector.fromArray(
    [Cx(stateSlider.$data.alpha, 0), Cx(stateSlider.$data.beta_r, stateSlider.$data.beta_i)], 
    [Dimension.qubit()]
  ),
  1, 
  [0]
);

var circuitHistoryBig2 = [];
circ = circ.saveTo(circuitHistoryBig2)
              .H(0).saveTo(circuitHistoryBig2)
              .X(0).saveTo(circuitHistoryBig2);

var klv = new Vue({
  el: '#ketlist6',
  template: "<ket-list-viewer :steps='stepsQuantumComputing' :dark-mode='false'/>",
  components: {
    KetListViewer,
  },
  data() {
    return {
      stepsQuantumComputing: [
        { value: 'Initial state', vector: circuitHistoryBig2[0].vector },
        { value: 'Apply H gate', vector: circuitHistoryBig2[1].vector },
        { value: 'Apply X gate', vector: circuitHistoryBig2[2].vector },
      ],
    }
  }
});

updateGates = function() {
  
  var gates = dnd.$data.selectedGates;
  
  var initialState = Vector.fromArray(
    [Cx(stateSlider.$data.alpha, 0), Cx(stateSlider.$data.beta_r, stateSlider.$data.beta_i)], 
    [Dimension.qubit()]
  );
  
  circ = new Circuit(
    initialState,
    1, 
    [0]
  );
  
  circuitHistoryBig2 = [];
  circ = circ.saveTo(circuitHistoryBig2);
  
  var i;
  for (i = gates.length - 1; i >= 0; i--) {
    switch(gates[i].name) {
      case 'X':
        circ.X(0).saveTo(circuitHistoryBig2);
        break;
      case 'Y':
        circ.Y(0).saveTo(circuitHistoryBig2);
        break;
      case 'Z':
        circ.Z(0).saveTo(circuitHistoryBig2);
        break;
      case 'H':
        circ.H(0).saveTo(circuitHistoryBig2);
        break;
       case 'I':
        circ.I(0).saveTo(circuitHistoryBig2);
        break;
      case 'S':
        circ.S(0).saveTo(circuitHistoryBig2);
        break;
      case 'T':
        circ.T(0).saveTo(circuitHistoryBig2);
        break;
      default:
        // default case
    }
  }
  
  
  klv.$data.stepsQuantumComputing.splice(0, klv.$data.stepsQuantumComputing.length);
  klv.$data.stepsQuantumComputing.push({ value: 'Initial state', vector: circuitHistoryBig2[0].vector });
  
  for(i = 1; i < circuitHistoryBig2.length; i++) {
    var namegate = gates[gates.length - i]?.name;
    klv.$data.stepsQuantumComputing.push({ 
      value: 'Apply ' + namegate + ' gate ', 
      vector: circuitHistoryBig2[i].vector });
  }
}


```

```{css, echo=FALSE}
.matrix-viewer {
  margin: auto;
}

.gate_title {
  font-size: 18px;
  font-weight: bold;
  text-align: left;
}

.matrices td {
  border: 10px solid #ffffff;
  background-color: rgba(0,0,0,0.03);
  padding: 3px 3px 3px 3px;
  font-size: 16px;
  font-weight: bold;
}

div .x-class {
  background-color: #ff0055;
  color: #ffffff;
  margin: 3px 3px 3px 3px;
  cursor: grab;
}

div .y-class {
  background-color: #5c00d3;
  color: #ffffff;
  margin: 3px 3px 3px 3px;
  cursor: grab;
}

div .z-class {
  background-color: #0071dd;
  color: #ffffff;
  margin: 3px 3px 3px 3px;
  cursor: grab;
}

div .h-class {
  background-color: #2e006a;
  color: #ffffff;
  margin: 3px 3px 3px 3px;
  cursor: grab;
}

div .i-class {
  background-color: rgb(0, 127, 18);
  color: #ffffff;
  margin: 3px 3px 3px 3px;
  cursor: grab;
}

div .s-class {
  background-color: rgb(132, 104, 165);
  color: #ffffff;
  margin: 3px 3px 3px 3px;
  cursor: grab;
}

div .t-class {
  background-color: rgb(97, 170, 181);
  color: #ffffff;
  margin: 3px 3px 3px 3px;
  cursor: grab;
}

div .chosen {
  transform: scale(1.1) rotate(-5deg);
  cursor: grabbing;
}

div .box-available {
  border-radius: 0px;
  border: none;
  background-color: rgba(0,0,0,0.05);
  padding: 15px 0px 0px 30px;
  width: 430px;
  height: 125px;
}

.legend-text {
  width: 130px;
  margin: 10px 0px 0px 00px;
  font-size: 15px;
}

div .box-selected {
  border-radius: 0px;
  border: none;
  background-color: rgba(0,0,0,0.05);
  padding: 15px 0px 0px 35px;
  width: auto;
  height: 125px;
}

.table-circuit {
  width: 100%;
  padding: 0px;
  border: 0px;
  margin: 0px;
  border-collapse: collapse;
}

.theta .rs-handle {
  background-color: #ff0055;
  box-shadow: 0px 0px 0px 0px #000;
}

.phi .rs-handle {
  background-color: #5c00d3;
  box-shadow: 0px 0px 0px 0px #000;
}

.round-slider-font {
  font-weight: 500;
  font-family: Asana Math;
}


```

